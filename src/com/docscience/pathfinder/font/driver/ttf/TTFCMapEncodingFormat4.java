package com.docscience.pathfinder.font.driver.ttf;

import java.io.IOException;

/**
 * Format 4: Segment mapping to delta values
 *  
 * <pre> 
 * Type   Name                    Description 
 * -----------------------------------------------------------------------------
 * USHORT format                  Format number is set to 4.  
 * USHORT length                  This is the length in bytes of the subtable.  
 * USHORT language                Please see "Note on the language field in 
 *                                'cmap' subtables" in this document. 
 * USHORT segCountX2              2 x segCount. 
 * USHORT searchRange             2 x (2**floor(log2(segCount))) 
 * USHORT entrySelector           log2(searchRange/2) 
 * USHORT rangeShift              2 x segCount - searchRange 
 * USHORT endCount[segCount]      End characterCode for each segment, last=0xFFFF. 
 * USHORT reservedPad             Set to 0. 
 * USHORT startCount[segCount]    Start character code for each segment. 
 * SHORT  idDelta[segCount]       Delta for all character codes in segment. 
 * USHORT idRangeOffset[segCount] Offsets into glyphIdArray or 0 
 * USHORT glyphIdArray[ ]         Glyph index array (arbitrary length) 
 * </pre>
 * 
 * @author wxin
 *
 */
public class TTFCMapEncodingFormat4 extends TTFCMapEncoding {

    /**
     * Generated by Eclipse 
     */
    private static final long serialVersionUID = 6274534172527334049L;
    
    private int length;
    private int language;
    private int segCountX2;
    private int searchRange;
    private int entrySelector;
    private int rangeShift;
    private int endCount[];
    private int startCount[];
    private int idDelta[];
    private int idRangeOffset[];
    private int glyphIdArray[];
    private int firstChar;
    private int lastChar;
    
    @Override
	public int getFirstChar() {
        return firstChar;
    }

    @Override
	public int getLastChar() {
        return lastChar;
    }

    public final int[] getEndCount() {
        return endCount;
    }

    public final int getEntrySelector() {
        return entrySelector;
    }

    public final int[] getGlyphIdArray() {
        return glyphIdArray;
    }

    public final int[] getIdDelta() {
        return idDelta;
    }

    public final int[] getIdRangeOffset() {
        return idRangeOffset;
    }

    public final int getLanguage() {
        return language;
    }

    public final int getLength() {
        return length;
    }

    public final int getRangeShift() {
        return rangeShift;
    }

    public final int getSearchRange() {
        return searchRange;
    }

    public final int getSegCountX2() {
        return segCountX2;
    }

    public final int[] getStartCount() {
        return startCount;
    }

    @Override
	public int getFormat() {
        return CMAP_FORMAT_4;
    }
    
    @Override
	public int getGlyphID(int code) {
        if (code < firstChar || code > lastChar) {
            return 0;
        }
        final int segCount = endCount.length;
        int seg = -1;
        for (int i=0; i<endCount.length; ++i) {
            if (endCount[i] >= code) {
                if (startCount[i] <= code) {
                    seg = i;
                }
                break;
            }
        }
        if (seg == -1) {
            return 0;
        }
        int range = idRangeOffset[seg];
        if (range != 0) {
            int start = startCount[seg];
            int index = (range / 2) + (code - start) - (segCount - seg);
            return glyphIdArray[index];
        }
        else {
            return (code + idDelta[seg]) & 0x0ffff;
        }
    }

    @Override
	public void read(long offset, TTFRandomReader rd)
            throws TTFFormatException, IOException {
        rd.setPosition(offset);
        if (rd.readTTFUShort() != CMAP_FORMAT_4) {
            throw new TTFFormatException("bad cmap encoding format number for format 4", rd.getPosition() - 2);
        }
        length = rd.readTTFUShort();
        language = rd.readTTFUShort();
        segCountX2 = rd.readTTFUShort();
        searchRange = rd.readTTFUShort();
        entrySelector = rd.readTTFUShort();
        rangeShift = rd.readTTFUShort();

        int segCount = segCountX2 / 2;
        if (segCount < 1) {
            throw new TTFFormatException("bad cmap encoding format 4 segCount", rd.getPosition() - 8);
        }
        
        endCount = new int[segCount];
        for (int i=0; i<segCount; ++i) {
            endCount[i] = rd.readTTFUShort();
        }
        if (rd.readTTFUShort() != 0) {
            throw new TTFFormatException("bad cmap encoding format 4 reserve byte", rd.getPosition() - 2);
        }
        
        startCount = new int[segCount];
        for (int i=0; i<segCount; ++i) {
            startCount[i] = rd.readTTFUShort();
        }
        
        firstChar = startCount[0];
        if (startCount[segCount - 1] == 0xffff) {
            if (segCount >= 2) {
                lastChar = endCount[segCount - 2];
            }
            else {
                lastChar = endCount[segCount - 1];
            }
        } else {
            lastChar = endCount[segCount - 1];
        }
        
        
        idDelta = new int[segCount];
        for (int i=0; i<segCount; ++i) {
            idDelta[i] = rd.readTTFShort();
        }
        
        idRangeOffset = new int[segCount];
        for (int i=0; i<segCount; ++i) {
            idRangeOffset[i] = rd.readTTFUShort();
        }
        
        int lengthOfGlyphIdArray = (length - (2 * 8) - (2 * segCount * 4)) / 2;
        
        glyphIdArray = new int[lengthOfGlyphIdArray];
        for (int i=0; i<lengthOfGlyphIdArray; ++i) {
            glyphIdArray[i] = rd.readTTFUShort();
        }
    }

}
